use owasm::{oei, ext};

pub fn run_scenario(scenario: u64, is_prepare: bool) {
  if is_prepare {
    match scenario {
      1 => run_infinite_loop(),
      3 => many_arithmatic_ops(),
      5 => alloc_many_heap_mem(),
      7 => alloc_many_stack_mem(),
      9 => get_many_call_data(),
      11 => ask_report_from_chain(),
      13 => ask_many_report_from_chain(),
      15 => save_return_data_twice(),
      _ => {},
    }
  } else {
    match scenario {
      2 => run_infinite_loop(),
      4 => many_arithmatic_ops(),
      6 => alloc_many_heap_mem(),
      8 => alloc_many_stack_mem(),
      10 => get_many_call_data(),
      12 => ask_report_from_chain(),
      14 => ask_many_report_from_chain(),
      16 => save_return_data_twice(),
      _ => {},
    }
  }
}

fn run_infinite_loop() {
  loop{};
}

fn many_arithmatic_ops() {
  let mut a: u64 = 0;
  let mut b: f64 = 1.0;
  for _n in 1..2000000000 {
    let mut _c: f64 = 0.0;
    a += 2;
    b = b/(a as f64);
    _c = b / 2.54464563;
  }
}

fn alloc_many_stack_mem() {
  let _wow: [u64; 100000000] = [99; 100000000];
}

fn alloc_many_heap_mem() {
  let _wow = vec![99; 4294967295];
}

fn get_many_call_data() {
  for _ in 1..10000000 {
    let _bytes = oei::get_calldata();
  }
}

fn ask_report_from_chain() {
  let _result: Option<f64> = ext::load_average(1);
}

fn ask_many_report_from_chain() {
  for _ in 1..10000000 {
    let _result: Option<f64> = ext::load_average(1);
  }
}

fn save_return_data_twice() {
  oei::save_return_data(&[1,2,3]);
  oei::save_return_data(&[1,2,3]);
}

